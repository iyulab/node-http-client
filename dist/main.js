class e{constructor(){this._isCancelled=!1,this.controller=new AbortController,this.callbacks=[]}get signal(){return this.controller.signal}get isCancelled(){return this._isCancelled}register(e){this.callbacks.push(e)}cancel(e){if(!this._isCancelled){this._isCancelled=!0,this.controller.abort();for(const t of this.callbacks)try{t(e)}catch(e){console.error("CancelToken callback error:",e)}}}throwIfCancelled(){if(this._isCancelled)throw new Error("Operation has been cancelled")}}class t{constructor(e){this._response=e}get ok(){return this._response.ok}get status(){return this._response.status}get statusText(){return this._response.statusText}get headers(){return this._response.headers}get url(){return this._response.url}get redirected(){return this._response.redirected}text(){return this._response.text()}json(){return this._response.json()}arrayBuffer(){return this._response.arrayBuffer()}async bytes(){const e=await this._response.arrayBuffer();return new Uint8Array(e)}blob(){return this._response.blob()}formData(){return this._response.formData()}async*stream(){const e=this._response.body?.getReader(),t=new TextDecoder("utf-8");if(!e)throw new Error("No response body available.");try{let s=!1,r="";const a=/\r?\n\r?\n/;for(;!s;){const{value:n,done:o}=await e.read();if(s=o,n){r+=t.decode(n,{stream:!0});const e=r.split(a);if(e.length>1){for(let t=0;t<e.length-1;t++){const s=this.parse(e[t].trim());s&&(yield s)}r=e[e.length-1]}}}if(r){const e=this.parse(r.trim());e&&(yield e)}}finally{e.releaseLock(),this._response.body?.cancel()}}parse(e){if(!e)return;const t=e.split(/\r?\n/).filter((e=>""!==e.trim()));if(0===t.length)return;const s={event:"message",data:""};for(const e of t){const t=e.indexOf(":");if(-1===t)continue;const r=e.slice(0,t).trim(),a=e.slice(t+1).trim();if("event"===r)s.event=a;else if("data"===r)s.data=s.data?`${s.data}\n${a}`:a;else if("id"===r)s.id=a;else if("retry"===r){const e=parseInt(a,10);isNaN(e)||(s.retry=e)}}return s.data?s:void 0}}class s{constructor(e){this.baseUrl=e.baseUrl,this.headers=e.headers,this.timeout=e.timeout,this.credentials=e.credentials,this.mode=e.mode,this.cache=e.cache,this.keepalive=e.keepalive}async head(e,t){const{baseUrl:s,path:r,query:a}=this.parseUrl(e);return this.send({method:"HEAD",baseUrl:s,path:r,query:a},t)}async get(e,t){const{baseUrl:s,path:r,query:a}=this.parseUrl(e);return this.send({method:"GET",baseUrl:s,path:r,query:a},t)}async post(e,t,s){const{baseUrl:r,path:a,query:n}=this.parseUrl(e);return this.send({method:"POST",baseUrl:r,path:a,query:n,body:t},s)}async put(e,t,s){const{baseUrl:r,path:a,query:n}=this.parseUrl(e);return this.send({method:"PUT",baseUrl:r,path:a,query:n,body:t},s)}async patch(e,t,s){const{baseUrl:r,path:a,query:n}=this.parseUrl(e);return this.send({method:"PATCH",baseUrl:r,path:a,query:n,body:t},s)}async delete(e,t){const{baseUrl:s,path:r,query:a}=this.parseUrl(e);return this.send({method:"DELETE",baseUrl:s,path:r,query:a},t)}async send(s,r){const a=this.buildUrl(s.baseUrl??this.baseUrl,s.path,s.query),n=new Headers(s.headers);this.headers&&Object.entries(this.headers).forEach((([e,t])=>{n.append(e,t)}));let o=s.body;"string"==typeof o?n.set("Content-Type","text/plain;charset=UTF-8"):"object"==typeof o&&(o instanceof Blob?n.set("Content-Type",o.type||"application/octet-stream"):o instanceof ArrayBuffer?n.set("Content-Type","application/octet-stream"):(n.set("Content-Type","application/json;charset=UTF-8"),o=JSON.stringify(o)));const i=r||new e,l=s.timeout??this.timeout,h=l?setTimeout((()=>i.cancel()),l):null;try{const e=await fetch(a.toString(),{method:s.method,headers:n,body:o,cache:s.cache??this.cache,credentials:s.credentials??this.credentials,mode:s.mode??this.mode,keepalive:s.keepalive??this.keepalive,signal:i.signal});return new t(e)}catch(e){throw e}finally{h&&clearTimeout(h)}}async*upload(e,t){const s=this.buildUrl(e.baseUrl??this.baseUrl,e.path,e.query),r=new XMLHttpRequest;r.open(e.method,s,!0);const a=e.timeout??this.timeout;a&&(r.timeout=a);const n=e.credentials??this.credentials;let o;if(n&&(r.withCredentials="include"===n||"same-origin"===n),e.headers&&Object.entries(e.headers).forEach((([e,t])=>{r.setRequestHeader(e,t)})),this.headers&&Object.entries(this.headers).forEach((([e,t])=>{r.setRequestHeader(e,t)})),e.body instanceof FormData)o=e.body;else if(Array.isArray(e.body)){const t=new FormData;for(let s=0;s<e.body.length;s++)t.append("files",e.body[s]);o=t}else{const t=new FormData;t.append("file",e.body),o=t}const i=[];for(r.upload.onprogress=e=>{if(e.lengthComputable){const t=Math.round(e.loaded/e.total*100);i.shift()?.({type:"progress",loaded:e.loaded,total:e.total,progress:t})}},r.onload=()=>{if(r.status>=200&&r.status<300){const e={},t=r.getAllResponseHeaders().split("\r\n");for(const s of t){const t=s.indexOf(": ");if(-1!==t){const r=s.substring(0,t).trim(),a=s.substring(t+2).trim();e[r]?e[r]=`${e[r]}, ${a}`:e[r]=a}}i.shift()?.({type:"success",status:r.status,headers:e,body:r.response})}else i.shift()?.({type:"failure",status:r.status,message:`Upload failed with status ${r.status}`})},r.onerror=()=>{i.shift()?.({type:"failure",message:"Network error occurred"})},r.ontimeout=()=>{i.shift()?.({type:"failure",message:"Request timed out"})},t&&t.register((()=>{r.abort()})),r.send(o);;){const e=await new Promise((e=>{i.push(e)}));if(yield e,"success"===e.type||"failure"===e.type)break}}download(e){const t=this.buildUrl(e.baseUrl??this.baseUrl,e.path,e.query),s=document.createElement("a");s.style.display="none",s.href=t.toString(),s.download="",document.body.appendChild(s),s.click(),document.body.removeChild(s)}buildUrl(e,t,s){if(!e)throw new Error("Base URL is required for building the request URL.");const r=t?new URL(e.endsWith("/")&&t.startsWith("/")?e+t.slice(1):e+t):new URL(e);return s&&Object.entries(s).forEach((([e,t])=>{null===t&&void 0===t||(Array.isArray(t)?t:[t]).forEach((t=>r.searchParams.append(e,t)))})),r}parseUrl(e){if(e.startsWith("http://")||e.startsWith("https://"))return{baseUrl:e};{if(!this.baseUrl)throw new Error("Base URL is required for relative URLs.");const[t,s]=e.split("?",2),r=s?Object.fromEntries(new URLSearchParams(s)):void 0;return{baseUrl:this.baseUrl,path:t,query:r}}}}export{e as CancelToken,s as HttpClient,t as HttpResponse};
